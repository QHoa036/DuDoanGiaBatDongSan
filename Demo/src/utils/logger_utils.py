#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
H·ªá th·ªëng ghi log n√¢ng cao cho ·ª©ng d·ª•ng D·ª± ƒëo√°n Gi√° B·∫•t ƒê·ªông S·∫£n Vi·ªát Nam

M√¥-ƒëun n√†y cung c·∫•p m·ªôt h·ªá th·ªëng ghi log to√†n di·ªán v·ªõi:
- Nhi·ªÅu c·∫•p ƒë·ªô log (DEBUG, INFO, WARNING, ERROR, CRITICAL)
- Ghi log ra file v√† console v·ªõi ƒë·ªãnh d·∫°ng t√πy ch·ªânh
- T√≠ch h·ª£p v·ªõi Streamlit ƒë·ªÉ hi·ªÉn th·ªã log trong giao di·ªán ng∆∞·ªùi d√πng
- H·ªó tr·ª£ ƒëa n·ªÅn t·∫£ng
- Theo d√µi metrics v√† hi·ªáu su·∫•t c·ªßa m√¥ h√¨nh
"""

import os
import logging
import sys
import time
from datetime import datetime
from typing import Dict, List, Any, Optional, Callable
import streamlit as st
import functools
import inspect
import threading
import json

# MARK: - M√†u s·∫Øc cho logger

class LogColors:
    """
    M√†u s·∫Øc cho log tr√™n console
    """
    RESET = "\033[0m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"

    # M√†u ch·ªØ
    BLACK = "\033[30m"
    RED = "\033[31m"
    GREEN = "\033[32m"
    YELLOW = "\033[33m"
    BLUE = "\033[34m"
    MAGENTA = "\033[35m"
    CYAN = "\033[36m"
    WHITE = "\033[37m"

    # M√†u n·ªÅn
    BG_BLACK = "\033[40m"
    BG_RED = "\033[41m"
    BG_GREEN = "\033[42m"
    BG_YELLOW = "\033[43m"
    BG_BLUE = "\033[44m"
    BG_MAGENTA = "\033[45m"
    BG_CYAN = "\033[46m"
    BG_WHITE = "\033[47m"

# MARK: - √Ånh x·∫° log

LEVEL_COLORS = {
    logging.DEBUG: LogColors.CYAN,
    logging.INFO: LogColors.GREEN,
    logging.WARNING: LogColors.YELLOW,
    logging.ERROR: LogColors.RED,
    logging.CRITICAL: f"{LogColors.BOLD}{LogColors.RED}"
}

# MARK: - ƒê·ªãnh d·∫°ng log

class CustomFormatter(logging.Formatter):
    """
    L·ªõp ƒë·ªãnh d·∫°ng log t√πy ch·ªânh v·ªõi m√†u s·∫Øc cho console
    """
    def __init__(self, use_colors=True, fmt=None, datefmt=None):
        if fmt is None:
            fmt = "[%(asctime)s] [%(levelname)s] %(message)s"
        if datefmt is None:
            datefmt = "%Y-%m-%d %H:%M:%S"

        self.use_colors = use_colors
        self.default_fmt = fmt
        super().__init__(fmt=fmt, datefmt=datefmt)

    def format(self, record):
        # T·∫°o b·∫£n sao c·ªßa record ƒë·ªÉ tr√°nh thay ƒë·ªïi b·∫£n g·ªëc
        formatted_record = logging.makeLogRecord(record.__dict__)

        # X·ª≠ l√Ω c√°c tr∆∞·ªùng h·ª£p l·ªói ƒë·∫∑c bi·ªát
        if formatted_record.exc_info:
            # ƒê·ªãnh d·∫°ng l·∫°i traceback
            formatted_record.exc_text = self.formatException(formatted_record.exc_info)

        levelname = formatted_record.levelname

        # Th√™m m√†u s·∫Øc cho log n·∫øu ƒë∆∞·ª£c b·∫≠t
        try:
            # Ki·ªÉm tra an to√†n tr∆∞·ªõc khi s·ª≠ d·ª•ng isatty()
            use_colors = self.use_colors and hasattr(sys, 'stderr') and sys.stderr and hasattr(sys.stderr, 'isatty') and sys.stderr.isatty()
            if use_colors:
                color = LEVEL_COLORS.get(formatted_record.levelno, LogColors.RESET)
                formatted_record.levelname = f"{color}{levelname}{LogColors.RESET}"
        except (AttributeError, TypeError):
            # An to√†n n·∫øu c√≥ l·ªói
            pass

        return super().format(formatted_record)

# MARK: - X·ª≠ l√Ω log cho Streamlit

class StreamlitHandler(logging.Handler):
    """
    Handler ghi log v√†o giao di·ªán Streamlit
    """
    def __init__(self, level=logging.INFO):
        super().__init__(level)
        self.logs = []
        self.max_logs = 100  # Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng log hi·ªÉn th·ªã

    def emit(self, record):
        try:
            msg = self.format(record)
            self.logs.append({
                'time': datetime.now().strftime("%H:%M:%S"),
                'level': record.levelname,
                'message': record.getMessage(),
                'formatted': msg
            })

            # Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng log
            if len(self.logs) > self.max_logs:
                self.logs.pop(0)

            # C·∫≠p nh·∫≠t UI n·∫øu c√≥ th·ªÉ
            self._update_ui()
        except Exception:
            self.handleError(record)

    def _update_ui(self):
        """
        C·∫≠p nh·∫≠t giao di·ªán Streamlit n·∫øu c√≥ th·ªÉ
        """
        if 'st_log_container' in st.session_state:
            with st.session_state.st_log_container:
                st.empty()
                for log in self.logs[-10:]:  # Ch·ªâ hi·ªÉn th·ªã 10 log g·∫ßn nh·∫•t
                    level = log['level']
                    if level == 'DEBUG':
                        st.text(f"üîç {log['time']} - {log['message']}")
                    elif level == 'INFO':
                        st.info(f"{log['time']} - {log['message']}")
                    elif level == 'WARNING':
                        st.warning(f"{log['time']} - {log['message']}")
                    elif level == 'ERROR' or level == 'CRITICAL':
                        st.error(f"{log['time']} - {log['message']}")
                    else:
                        st.text(f"{log['time']} - {log['message']}")

# MARK: - L∆∞u tr·ªØ v√† qu·∫£n l√Ω logger
# Thread-local storage ƒë·ªÉ l∆∞u tr·ªØ th√¥ng tin logger
_thread_local = threading.local()

def get_logger(name=None, level=None, log_file=None, enable_streamlit=False) -> logging.Logger:
    """
    T·∫°o v√† c·∫•u h√¨nh logger
    """
    # X√°c ƒë·ªãnh t√™n logger
    if name is None:
        # L·∫•y t√™n module g·ªçi
        frame = inspect.currentframe().f_back
        module = inspect.getmodule(frame)
        name = module.__name__ if module else 'root'

    # Ki·ªÉm tra xem logger ƒë√£ t·ªìn t·∫°i ch∆∞a
    if hasattr(_thread_local, 'loggers') and name in _thread_local.loggers:
        return _thread_local.loggers[name]

    # T·∫°o logger m·ªõi
    logger = logging.getLogger(name)

    # Thi·∫øt l·∫≠p c·∫•p ƒë·ªô log
    if level is None:
        level = logging.ERROR  # TƒÉng c·∫•p ƒë·ªô log m·∫∑c ƒë·ªãnh l√™n ERROR ƒë·ªÉ gi·∫£m log t·ªëi thi·ªÉu
    logger.setLevel(level)

    # T·∫°o b·ªô l·ªçc ƒë·ªÉ lo·∫°i b·ªè c√°c tin nh·∫Øn log kh√¥ng c·∫ßn thi·∫øt
    class ComprehensiveLogFilter(logging.Filter):
        def filter(self, record):
            # L·ªçc ra c√°c log kh√¥ng c·∫ßn thi·∫øt
            message = record.getMessage().lower()
            filtered_patterns = [
                'starting streamlit',
                'ngrok tunnel',
                'starting up',
                'running on',
                'java_tool_options',
                'picked up',
                'listening on',
                'started session',
                'connected to',
                'initiating',
                'loading',
                'loading settings',
                'retrieving',
                'connection established',
                'binding to',
                'set current project',
                'http-8501',
                'waiting',
                'downloading',
                't=',
                'lvl=info',
                'obj=tunnels',
                'ivy',
                'hadoop',
                'spark',
                'jvm',
                'jar',
                'default cache',
                'artifacts',
                'modules',
                'confs',
                'resolution',
                'apache',
                'native',
                'found',
                'resolver',
                'opening'
            ]

            # Ki·ªÉm tra xem th√¥ng ƒëi·ªáp c√≥ ch·ª©a b·∫•t k·ª≥ m·∫´u n√†o kh√¥ng
            for pattern in filtered_patterns:
                if pattern in message:
                    return False
            return True

    # NgƒÉn ch·∫∑n vi·ªác truy·ªÅn log l√™n logger cha
    # ƒê√¢y l√† nguy√™n nh√¢n ch√≠nh g√¢y ra c√°c log tr√πng l·∫∑p
    logger.propagate = False

    # X√≥a t·∫•t c·∫£ handler hi·ªán c√≥
    for handler in logger.handlers[:]:
        logger.removeHandler(handler)

    # Th√™m handler cho console v·ªõi b·ªô l·ªçc
    console_handler = logging.StreamHandler(sys.stdout)  # S·ª≠ d·ª•ng stdout thay v√¨ stderr ƒë·ªÉ c√≥ m√†u s·∫Øc
    console_handler.setFormatter(CustomFormatter(use_colors=True))

    # √Åp d·ª•ng b·ªô l·ªçc cho console handler
    console_handler.addFilter(ComprehensiveLogFilter())
    logger.addHandler(console_handler)

    # Th√™m handler cho file n·∫øu ƒë∆∞·ª£c y√™u c·∫ßu
    if log_file is not None:
        # ƒê·∫£m b·∫£o th∆∞ m·ª•c logs t·ªìn t·∫°i
        log_dir = os.path.dirname(log_file)
        os.makedirs(log_dir, exist_ok=True)

        file_handler = logging.FileHandler(log_file, encoding='utf-8')
        file_formatter = logging.Formatter(
            "[%(asctime)s] [%(name)s] %(message)s",
            "%Y-%m-%d %H:%M:%S"
        )
        file_handler.setFormatter(file_formatter)
        logger.addHandler(file_handler)

    # Th√™m handler cho Streamlit n·∫øu ƒë∆∞·ª£c y√™u c·∫ßu
    if enable_streamlit:
        streamlit_handler = StreamlitHandler()
        streamlit_formatter = logging.Formatter(
            "%(message)s",
            "%H:%M:%S"
        )
        streamlit_handler.setFormatter(streamlit_formatter)
        logger.addHandler(streamlit_handler)

    # L∆∞u logger v√†o thread-local storage
    if not hasattr(_thread_local, 'loggers'):
        _thread_local.loggers = {}
    _thread_local.loggers[name] = logger

    return logger

# MARK: - Decorator v√† ti·ªán √≠ch

def log_execution_time(func=None, logger=None, level=logging.INFO):
    """
    Decorator ƒë·ªÉ ghi log th·ªùi gian th·ª±c thi c·ªßa h√†m
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # X√°c ƒë·ªãnh logger
            nonlocal logger
            if logger is None:
                module = inspect.getmodule(func)
                logger_name = module.__name__ if module else func.__module__
                logger = get_logger(logger_name)

            # Ghi log b·∫Øt ƒë·∫ßu
            logger.log(level, f"B·∫Øt ƒë·∫ßu th·ª±c thi {func.__name__}")
            start_time = time.time()

            try:
                result = func(*args, **kwargs)
                end_time = time.time()
                execution_time = end_time - start_time

                # Ghi log k·∫øt th√∫c
                logger.log(level, f"Ho√†n th√†nh {func.__name__} trong {execution_time:.4f} gi√¢y")
                return result
            except Exception as e:
                end_time = time.time()
                execution_time = end_time - start_time

                # Ghi log l·ªói
                logger.exception(f"L·ªói trong {func.__name__} sau {execution_time:.4f} gi√¢y: {str(e)}")
                raise

        return wrapper

    # H·ªó tr·ª£ s·ª≠ d·ª•ng decorator v·ªõi ho·∫∑c kh√¥ng c√≥ tham s·ªë
    if func is not None:
        return decorator(func)
    return decorator

def setup_streamlit_logging_container():
    """
    Thi·∫øt l·∫≠p container ƒë·ªÉ hi·ªÉn th·ªã log trong Streamlit
    G·ªçi h√†m n√†y trong view tr∆∞·ªõc khi s·ª≠ d·ª•ng logger v·ªõi enable_streamlit=True
    """
    if 'st_log_container' not in st.session_state:
        st.session_state.st_log_container = st.container()

def get_all_logs(max_count=None) -> List[Dict]:
    """
    L·∫•y t·∫•t c·∫£ log ƒë√£ ƒë∆∞·ª£c ghi nh·∫≠n b·ªüi StreamlitHandler
    """
    logs = []

    # Thu th·∫≠p log t·ª´ t·∫•t c·∫£ logger
    if hasattr(_thread_local, 'loggers'):
        for logger in _thread_local.loggers.values():
            for handler in logger.handlers:
                if isinstance(handler, StreamlitHandler):
                    logs.extend(handler.logs)

    # S·∫Øp x·∫øp theo th·ªùi gian
    logs.sort(key=lambda x: x['time'])

    # Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng n·∫øu c·∫ßn
    if max_count is not None and max_count > 0:
        logs = logs[-max_count:]

    return logs

def configure_root_logger(level=logging.INFO, log_file=None, enable_streamlit=False):
    """
    C·∫•u h√¨nh logger g·ªëc c·ªßa ·ª©ng d·ª•ng
    """
    # T·∫°o th∆∞ m·ª•c logs trong th∆∞ m·ª•c src
    if log_file is None:
        # L·∫•y ƒë∆∞·ªùng d·∫´n ƒë·∫øn th∆∞ m·ª•c src (ch·ªâ ƒëi l√™n 1 c·∫•p t·ª´ utils)
        src_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        logs_dir = os.path.join(src_dir, 'logs')
        os.makedirs(logs_dir, exist_ok=True)
        timestamp = datetime.now().strftime("%Y%m%d")
        log_file = os.path.join(logs_dir, f"app_{timestamp}.log")

    # C·∫•u h√¨nh logger g·ªëc
    root_logger = get_logger("root", level=level, log_file=log_file, enable_streamlit=enable_streamlit)

    # ƒê·∫∑t logger g·ªëc cho logging module
    logging.root = root_logger

    return root_logger

# MARK: - Theo d√µi metrics v√† hi·ªáu su·∫•t

class MetricsLogger:
    """
    L·ªõp ti·ªán √≠ch ƒë·ªÉ theo d√µi metrics v√† hi·ªáu su·∫•t c·ªßa m√¥ h√¨nh
    """
    def __init__(self, name: str, metrics_service=None):
        """
        Kh·ªüi t·∫°o logger cho metrics
        """
        self.logger = get_logger(f"metrics.{name}")
        self.metrics_service = metrics_service
        self.name = name
        self._history = {}

    def log_training_metrics(self, metrics: Dict[str, float], model_name: str):
        """
        Ghi l·∫°i c√°c metrics trong qu√° tr√¨nh hu·∫•n luy·ªán m√¥ h√¨nh
        """
        metrics_str = ", ".join([f"{k}={v:.4f}" for k, v in metrics.items()])
        self.logger.info(f"M√¥ h√¨nh {model_name} - Metrics: {metrics_str}")

        # L∆∞u v√†o metrics service n·∫øu c√≥
        if self.metrics_service:
            self.metrics_service.add_metrics(model_name, metrics)

        # L∆∞u v√†o l·ªãch s·ª≠ n·ªôi b·ªô
        if model_name not in self._history:
            self._history[model_name] = {}

        for metric_name, value in metrics.items():
            if metric_name not in self._history[model_name]:
                self._history[model_name][metric_name] = []
            self._history[model_name][metric_name].append(value)

    def log_prediction(self, input_data: Dict[str, Any], prediction: float, confidence: Optional[float] = None):
        """
        Ghi l·∫°i th√¥ng tin v·ªÅ m·ªôt d·ª± ƒëo√°n
        """
        msg = f"D·ª± ƒëo√°n: {prediction:.2f}"
        if confidence:
            msg += f", ƒê·ªô tin c·∫≠y: {confidence:.2f}"

        # Ghi log chi ti·∫øt ·ªü c·∫•p ƒë·ªô debug
        self.logger.debug(f"Input: {input_data}, {msg}")

        # Ghi log t·ªïng quan ·ªü c·∫•p ƒë·ªô info
        self.logger.info(msg)

    def log_performance(self, operation: str, duration_ms: float):
        """
        Ghi l·∫°i hi·ªáu su·∫•t c·ªßa m·ªôt thao t√°c
        """
        self.logger.info(f"Hi·ªáu su·∫•t - {operation}: {duration_ms:.2f}ms")

        # L∆∞u v√†o metrics service n·∫øu c√≥
        if self.metrics_service:
            perf_metrics = {f"perf_{operation}": duration_ms}
            self.metrics_service.add_metrics(f"{self.name}_performance", perf_metrics)

    def timing_decorator(self, func):
        """
        Decorator ƒë·ªÉ ƒëo th·ªùi gian th·ª±c thi c·ªßa m·ªôt h√†m

        Usage:
            @metrics_logger.timing_decorator
            def my_function():
                pass
        """
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            start_time = time.time()
            result = func(*args, **kwargs)
            end_time = time.time()

            duration_ms = (end_time - start_time) * 1000
            self.log_performance(func.__name__, duration_ms)

            return result
        return wrapper


# Ti·ªán √≠ch ƒë·ªÉ l·∫•y timestamp ƒë·ªãnh d·∫°ng chu·∫©n
def get_timestamp() -> str:
    """
    L·∫•y timestamp hi·ªán t·∫°i theo ƒë·ªãnh d·∫°ng chu·∫©n
    """
    return datetime.now().strftime("%Y%m%d_%H%M%S")


# Ti·ªán √≠ch ƒë·ªÉ format th·ªùi gian
def format_duration(milliseconds: float) -> str:
    """
    Format th·ªùi gian th·ª±c thi th√†nh chu·ªói d·ªÖ ƒë·ªçc
    """
    if milliseconds < 1000:
        return f"{milliseconds:.2f}ms"

    seconds = milliseconds / 1000
    if seconds < 60:
        return f"{seconds:.2f}s"

    minutes = seconds / 60
    seconds_remainder = seconds % 60
    return f"{int(minutes)}m {seconds_remainder:.2f}s"
